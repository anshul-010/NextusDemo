import { expect } from "vitest"

function Sum(a,b){
    return (a+b)
}




test('check sum work',()=>{
    expect(Sum(2,3)).toBe(5)
})

    // Handle undefined parameters
    test('should return NaN when parameters are undefined', () => {
        const result = Sum(undefined, undefined);
        expect(result).toBe(NaN);
      });

          // Add a positive and negative number and return their sum
    test('should return correct sum when adding a positive and negative number', () => {
        const result = Sum(5, -3);
        expect(result).toBe(2);
      });

      // Generated by Qodo Gen

describe('Sum', () => {

    // Add two positive integers and return their sum
    it('should return correct sum when adding two positive integers', () => {
      const result = Sum(2, 3);
      expect(result).toBe(5);
    });

    // Handle undefined parameters
    it('should return NaN when parameters are undefined', () => {
      const result = Sum(undefined, undefined);
      expect(result).toBe(NaN);
    });

    // Add a positive and negative number and return their sum
    it('should return correct sum when adding a positive and negative number', () => {
      const result = Sum(5, -3);
      expect(result).toBe(2);
    });

    // Handle zero as one of the parameters
    test('should return the other number when one parameter is zero', () => {
      const result1 = Sum(0, 5);
      expect(result1).toBe(5);
  
      const result2 = Sum(7, 0);
      expect(result2).toBe(7);
    });
});

    // Handle memory usage with large numbers
    test('should return correct sum when adding two large numbers', () => {
        const largeNumber1 = 9007199254740991; // Maximum safe integer in JavaScript
        const largeNumber2 = 9007199254740991;
        const result = Sum(largeNumber1, largeNumber2);
        expect(result).toBe(18014398509481982);
      });
 
    test('should handle multiplication precedence correctly', () => {
        const result1 = Sum(2, 3) * 4;
        const result2 = Sum(2, 3 * 4);
        expect(result1).toBe(20);
        expect(result2).toBe(14);
      });

      // Generated by Qodo Gen

describe('Sum', () => {

    // Add two positive integers and return their sum
    it('should return correct sum when adding two positive integers', () => {
      const result = Sum(2, 3);
      expect(result).toBe(5);
    });

    // Handle undefined parameters
    it('should return NaN when parameters are undefined', () => {
      const result = Sum(undefined, undefined);
      expect(result).toBe(NaN);
    });

    // Add a positive and negative number and return their sum
    it('should return correct sum when adding a positive and negative number', () => {
      const result = Sum(5, -3);
      expect(result).toBe(2);
    });

    // Handle zero as one of the parameters
    it('should return the other number when one parameter is zero', () => {
      const result1 = Sum(0, 5);
      expect(result1).toBe(5);
  
      const result2 = Sum(7, 0);
      expect(result2).toBe(7);
    });

    // Handle memory usage with large numbers
    it('should return correct sum when adding two large numbers', () => {
      const largeNumber1 = 9007199254740991; // Maximum safe integer in JavaScript
      const largeNumber2 = 9007199254740991;
      const result = Sum(largeNumber1, largeNumber2);
      expect(result).toBe(18014398509481982);
    });

    // Compare with multiplication precedence (Sum(2,3) * 4 vs Sum(2,3*4))
    it('should handle multiplication precedence correctly', () => {
      const result1 = Sum(2, 3) * 4;
      const result2 = Sum(2, 3 * 4);
      expect(result1).toBe(20);
      expect(result2).toBe(14);
    });

    // Handle type coercion between numbers and numeric strings
    it('should return correct sum when adding a number and a numeric string', () => {
      const result = Sum(2, '3');
      expect(result).toBe(23);
    });

    // Handle NaN values
    test('should return NaN when one or both inputs are NaN', () => {
      const result1 = Sum(NaN, 3);
      const result2 = Sum(2, NaN);
      const result3 = Sum(NaN, NaN);
      expect(result1).toBeNaN();
      expect(result2).toBeNaN();
      expect(result3).toBeNaN();
    });
});


